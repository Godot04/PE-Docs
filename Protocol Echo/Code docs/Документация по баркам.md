# Система барков (Speech Barks) — полная документация

<div class="header" align="Left">

<span style="font-size: 1.2em;">Данный документ — сводка информации по <span style="color:#66FF66">новым файлам</span>, <span style="color:#FFFF66">системам/компонентам</span> и <span style="color:#FF9966">изменениям в существующих файлах</span> связанным с системой барков (Speech Barks).</span>

---

## Оглавление

1. [Общая суть барков](#общая-суть-барков)
2. [Архитектура: как всё связано](#архитектура-как-всё-связано)
3. [Новые файлы — Ядро системы (Shared)](#новые-файлы--ядро-системы-shared)
4. [Новые файлы — Сервер](#новые-файлы--сервер)
5. [Новые файлы — Клиент](#новые-файлы--клиент)
6. [Изменения в существующих файлах](#изменения-в-существующих-файлах)
7. [YAML-прототипы и ресурсы](#yaml-прототипы-и-ресурсы)
8. [Локализация](#локализация)
9. [CVars — настройки администратора](#cvars--настройки-администратора)
10. [Путь данных: от нажатия Enter до звука](#путь-данных-от-нажатия-enter-до-звука)
11. [Частые вопросы для новых кодеров](#частые-вопросы-для-новых-кодеров)

---

## Общая суть барков

Когда игрок пишет что-то в чат, система барков проигрывает серию коротких звуков, имитируя «живую речь» — как в Undertale, Animal Crossing и подобных играх. 

Как это работает на пальцах:
1. Игрок набирает сообщение и нажимает Enter.
2. Сервер получает сообщение и вызывает событие «кто-то говорит» (`EntitySpokeEvent`).
3. Система барков ловит это событие и смотрит, какой барк выбран у персонажа (например "Стандарт 1").
4. Сервер отправляет всем ближайшим игрокам сетевое событие: «проиграй вот этот звук с такими параметрами».
5. Клиент каждого игрока получает событие и проигрывает звуки — по одному звуку на каждые ~3 символа сообщения, с небольшой случайной паузой между ними.

Параметры которые настраивает игрок:
- **Барк (Proto)** — выбор набора звуков (например "Стандарт 1", "Андертейл 1" и т.д.)
- **Высота тона (Pitch)** — насколько высокий/низкий голос (от 0.6 до 1.5)
- **Мин. задержка (MinVar)** — минимальная пауза между звуками (в секундах)
- **Макс. задержка (MaxVar)** — максимальная пауза между звуками (в секундах)

---

## Архитектура

```
Схема потока данных:

[Игрок печатает в чат]
        │
        ▼
[Сервер: ChatSystem → EntitySpokeEvent]
        │
        ▼
[Сервер: SpeechBarksSystem.OnEntitySpoke()]
   ├── Берёт BarkData из SpeechBarksComponent персонажа
   ├── Вызывает TransformSpeakerBarkEvent (маска голоса может подменить барк)
   └── Рассылает PlaySpeechBarksEvent всем игрокам в радиусе 10 тайлов
        │
        ▼
[Клиент: SpeechBarksSystem.OnEntitySpoke()]
   ├── Получает PlaySpeechBarksEvent по сети
   ├── Рассчитывает кол-во звуков = длина_сообщения / 3
   └── В цикле проигрывает звуки с случайным питчем и паузой
```

---

## <span style="color:#66FF66">Новые файлы — Ядро системы (Shared)</span>

### 1. Content.Shared/_ECHO/Barks/BarkPrototype.cs

Этот файл определяет два ключевых класса: **BarkPrototype** и **BarkData**.

#### BarkPrototype — прототип барка

```csharp
[Prototype("speechBark")]
public sealed partial class BarkPrototype : IPrototype
{
    [IdDataField]
    public string ID { get; private set; } = default!;

    [DataField]
    public bool RoundStart = true;

    [DataField]
    public string Name = "Default";

    [DataField]
    public string Category = "Standard_barks";

    [DataField(required: true)]
    public SoundSpecifier Sound { get; private set; } = default!;
}
```

**Что это:** Шаблон барка, который загружается из YAML-файлов. Каждый барк в игре (Стандарт 1, Андертейл 1 и т.д.) — это один прототип.

**Поля:**
- `ID` — уникальный идентификатор, например `"Human1"`. Задаётся через `[IdDataField]` — это значит, что ID берётся из поля `id` в YAML.
- `RoundStart` — можно ли выбрать этот барк при создании персонажа. Если `false`, барк используется только внутри игры (например, для призраков или роботов).
- `Name` — локализационный ключ имени (например `"bark-Human1"`, который в файле локализации превращается в "Стандарт 1").
- `Category` — категория для группировки в UI (например `"Standard_barks"`, `"Undertale_barks"`).
- `Sound` — `SoundSpecifier` — ссылка на звуковой файл или коллекцию звуков. Атрибут `required: true` означает, что без звука прототип не загрузится.

**Пример YAML:**
```yaml
- type: speechBark
  id: Human1
  name: bark-Human1
  category: Standard_barks
  sound:
    path: /Audio/_ECHO/Barks/speak_1.ogg
```

#### BarkData — данные барка конкретного персонажа

```csharp
[DataDefinition]
[Serializable, NetSerializable]
public sealed partial class BarkData
{
    public ProtoId<BarkPrototype> Proto = "Human1";
    public SoundSpecifier? Sound = null;
    public float MinVar = 0.1f;
    public float MaxVar = 0.5f;
    public float Pitch = 1f;
}
```

**Что это:** Конкретные настройки барка игрока. В отличие от `BarkPrototype` (шаблон), `BarkData` хранит индивидуальные параметры: какой барк выбран + настройки питча и задержки.

**Атрибуты:**
- `[DataDefinition]` — позволяет YAML-сериализатору работать с этим классом.
- `[Serializable, NetSerializable]` — позволяет отправлять этот объект по сети (от сервера к клиенту) и сохранять в базу данных.

**Поля:**
- `Proto` — ID выбранного прототипа. Тип `ProtoId<BarkPrototype>` — специальный тип-обёртка, который хранит строку-ID, но при этом «знает», что это ID именно барка.
- `Sound` — кэшированная ссылка на звук. Заполняется при применении к сущности через `SetBarkData()`.
- `MinVar` / `MaxVar` — диапазон случайной паузы между звуками (в секундах).
- `Pitch` — базовая высота тона.

**Паттерн With-методов (иммутабельность):**
```csharp
public BarkData WithProto(string proto)
{
    var data = Copy();    // Создаём копию
    data.Proto = proto;   // Меняем одно поле
    return data;          // Возвращаем новый объект
}
```
Этот паттерн используется везде в SS14: вместо того чтобы менять объект напрямую, мы создаём его **копию** с изменённым полем. Это нужно потому что профиль персонажа — иммутабельный (неизменяемый) объект. Каждое изменение создаёт новый профиль.

**MemberwiseEquals** — сравнивает два `BarkData` поле за поле. Используется при проверке «были ли изменения в профиле» (чтобы кнопка «Сохранить» стала активной).

---

### 2. Content.Shared/_ECHO/Barks/Components/SpeechBarksComponent.cs

```csharp
[RegisterComponent, NetworkedComponent]
public sealed partial class SpeechBarksComponent : Component
{
    [DataField, ViewVariables(VVAccess.ReadWrite)]
    public BarkData Data = new();
}
```

**Что это:** Компонент, который прикрепляется к сущности персонажа. Содержит один объект `BarkData` — настройки барка этого конкретного персонажа.

**Атрибуты:**
- `[RegisterComponent]` — регистрирует компонент в системе, чтобы его можно было добавлять к сущностям.
- `[NetworkedComponent]` — автоматически синхронизирует данные компонента между сервером и клиентом.
- `[DataField]` — позволяет задать значение из YAML-прототипа сущности.
- `[ViewVariables(VVAccess.ReadWrite)]` — позволяет просматривать и менять значение в отладочном инструменте View Variables (VV) прямо в игре.

**Где добавляется:** Компонент прописан в YAML-прототипе сущности персонажа (например в `BaseMobHuman`). Когда игрок спавнится, компонент создаётся автоматически, а его данные заполняются из профиля через `SetBarkData()`.

---

### 3. Content.Shared/_ECHO/Barks/Events/PlaySpeechBarksEvent.cs

```csharp
[Serializable, NetSerializable]
public sealed class PlaySpeechBarksEvent : EntityEventArgs
{
    public NetEntity? Source;
    public string? Message;
    public SoundSpecifier SoundSpecifier;
    public float Pitch;
    public float LowVar;
    public float HighVar;
    public bool IsWhisper;
}
```

**Что это:** Сетевое событие, которое сервер отправляет клиентам. Содержит всю информацию для проигрывания барка.

**Атрибуты:**
- `EntityEventArgs` — базовый класс для сетевых событий в SS14.
- `[Serializable, NetSerializable]` — ОБЯЗАТЕЛЬНО для любого события, отправляемого по сети.

**Поля:**
- `Source` — `NetEntity` (сетевой ID) сущности, которая говорит. Тип `NetEntity` — это ID сущности в формате, понятном и серверу и клиенту (в отличие от обычного `EntityUid`, который локален).
- `Message` — текст сообщения. Нужен чтобы клиент рассчитал количество звуков.
- `SoundSpecifier` — какой звук проигрывать.
- `Pitch` — высота тона.
- `LowVar` / `HighVar` — диапазон паузы.
- `IsWhisper` — шёпот ли это (влияет на громкость и дальность слышимости).

**Путь события:** `Сервер (RaiseNetworkEvent)` → `Сеть` → `Клиент (SubscribeNetworkEvent)`

---

### 4. Content.Shared/_ECHO/Barks/Events/TransformSpeakerBarkEvent.cs

```csharp
public sealed class TransformSpeakerBarkEvent : EntityEventArgs, IInventoryRelayEvent
{
    public EntityUid Sender;
    public BarkData Data;
    public SlotFlags TargetSlots { get; } = SlotFlags.WITHOUT_POCKET;
}
```

**Что это:** Локальное событие, которое позволяет предметам менять барк говорящего.

**Зачем нужно:** Маска голоса может менять не только имя, но и барк. Это событие происходит через инвентарь (благодаря `IInventoryRelayEvent`), и маска голоса берет его и подменяет данные.

**Поля:**
- `Sender` — кто говорит.
- `Data` — данные барка (изначально — настоящие данные персонажа, но маска может их перезаписать).
- `TargetSlots` — какие слоты инвентаря проверять. `SlotFlags.WITHOUT_POCKET` = все слоты кроме карманов.
---

### 5. Content.Shared/_ECHO/Barks/Systems/SharedSpeechBarksSystem.cs

```csharp
public abstract class SharedSpeechBarksSystem : EntitySystem
{
    [Dependency] private readonly IPrototypeManager _proto = default!;

    public const string DefaultBark = "Human1";

    public void SetBarkData(EntityUid uid, BarkData data, SpeechBarksComponent? comp = null)
    {
        if (!Resolve(uid, ref comp, false))
            return;

        comp.Data = data;
        comp.Data.Sound = _proto.Index(comp.Data.Proto).Sound;
    }
}
```

**Что это:** Базовый (абстрактный) класс системы барков, общий для сервера и клиента.

**Ключевые моменты:**
- `abstract class` — нельзя создать напрямую. Сервер и клиент наследуют от него свои версии.
- `EntitySystem` — базовый класс для всех систем.
- `[Dependency]` — Dependency Injection (DI). Движок автоматически подставит нужный объект `IPrototypeManager` при создании системы.

**Метод `SetBarkData()`:**
```csharp
public void SetBarkData(EntityUid uid, BarkData data, SpeechBarksComponent? comp = null)
```
Применяет настройки барка к сущности.
1. `Resolve(uid, ref comp, false)` — пытается получить `SpeechBarksComponent` у сущности. Если компонента нет — просто выходит (благодаря `false` — без ошибки).
2. `comp.Data = data` — записывает данные.
3. `comp.Data.Sound = _proto.Index(comp.Data.Proto).Sound` — находит прототип по ID и кэширует звук. Это нужно потому что `BarkData` хранит только строку-ID прототипа, а для проигрывания нужен сам объект звука.

**`DefaultBark = "Human1"`** — барк по умолчанию, если у персонажа не задан никакой.

---

### 6. Content.Shared/_ECHO/Barks/Systems/SharedVoiceMaskSystem.cs

```csharp
public sealed class VoiceMaskChangeBarkMessage : BoundUserInterfaceMessage
{
    public string Proto { get; }
}

public sealed class VoiceMaskChangeBarkPitchMessage : BoundUserInterfaceMessage
{
    public string Pitch { get; }
}
```

**Что это:** Сетевые сообщения от UI маски голоса к серверу. Когда игрок меняет барк или питч в интерфейсе голосовой маске, клиент отправляет эти сообщения серверу.

**`BoundUserInterfaceMessage`** — базовый класс для сообщений, привязанных к конкретному UI окну (BUI). Отличие от обычных сетевых событий: BUI-сообщения привязаны к конкретной сущности (голосовой маске).

---

### 7. Content.Shared/_ECHO/CCVar/CCVars.cs

```csharp
[CVarDefs]
public sealed class UCCVars
{
    public static readonly CVarDef<bool> BarksEnabled = ...;
    public static readonly CVarDef<float> BarksMaxPitch = ...;
    public static readonly CVarDef<float> BarksMinPitch = ...;
    public static readonly CVarDef<float> BarksMinDelay = ...;
    public static readonly CVarDef<float> BarksMaxDelay = ...;
    public static readonly CVarDef<float> BarksVolume = ...;
}
```

**Что это:** Конфигурационные переменные (CVars) — настройки, которые админ может менять без рекомпиляции сервера.

**Каждая переменная:**

| CVar              |Значения| Флаги                       | Описание                            |
|-------------------|--------|-----------------------------|-------------------------------------|
| `barks.enabled`   | `true` | SERVER, REPLICATED, ARCHIVE | Включены ли барки вообще.           |
| `barks.max_pitch` | `1.5`  | SERVER, REPLICATED, ARCHIVE | Максимальная высота тона            |
| `barks.min_pitch` | `0.6`  | SERVER, REPLICATED, ARCHIVE | Минимальная высота тона             |
| `barks.min_delay` | `0.1`  | SERVER, REPLICATED, ARCHIVE | Минимальная пауза между звуками     |
| `barks.max_delay` | `0.6`  | SERVER, REPLICATED, ARCHIVE | Максимальная пауза                  |
| `barks.volume`    | `1.0`  | CLIENTONLY, ARCHIVE         | Громкость барков (только на клиенте)|

**Флаги:**
- `SERVER` — значение хранится на сервере.
- `REPLICATED` — сервер отправляет значение клиентам (чтобы UI мог показать лимиты).
- `ARCHIVE` — значение сохраняется при перезапуске сервера.
- `CLIENTONLY` — настройка только клиента (каждый игрок настраивает сам).

---

## <span style="color:#66FF66">Новые файлы — Сервер</span>

### 1. Content.Server/_ECHO/Barks/Systems/SpeechBarksSystem.cs

Это **главный серверный файл** системы барков. Через него проходит каждое сообщение в чате.

```csharp
public sealed class SpeechBarksSystem : SharedSpeechBarksSystem
```

Наследуется от `SharedSpeechBarksSystem` (получает метод `SetBarkData()`).

#### Зависимости (Dependency Injection)

```csharp
[Dependency] private readonly IPrototypeManager _proto = default!;
[Dependency] private readonly IConfigurationManager _cfg = default!;
[Dependency] private readonly ChatSystem _chat = default!;
[Dependency] private readonly EntityLookupSystem _lookup = default!;
[Dependency] private readonly MindSystem _mind = default!;
[Dependency] private readonly ISharedPlayerManager _player = default!;
[Dependency] private readonly SharedAudioSystem _audio = default!;
```

- `_proto` — доступ к базе прототипов (чтобы по ID `"Human1"` получить объект со звуком).
- `_cfg` — доступ к CVars (проверка `barks.enabled`).
- `_lookup` — поиск сущностей в радиусе (`GetEntitiesInRange`).
- `_mind` — доступ к «разуму» (связь между сущностью и игроком).
- `_player` — менеджер игроков (для получения информации игрока).

#### Initialize() — подписка на события

```csharp
public override void Initialize()
{
    base.Initialize();
    _cfg.OnValueChanged(UCCVars.BarksEnabled, v => _isEnabled = v, true);
    SubscribeLocalEvent<SpeechBarksComponent, EntitySpokeEvent>(OnEntitySpoke);
}
```

1. `_cfg.OnValueChanged(...)` — подписка на изменение CVarа. Когда игрок меняет `barks.enabled`, переменная `_isEnabled` обновляется автоматически. Параметр `true` в конце означает «сразу вызови callback с текущим значением» (чтобы `_isEnabled` инициализировалось).

2. `SubscribeLocalEvent<SpeechBarksComponent, EntitySpokeEvent>(OnEntitySpoke)` 
Объяснение синтаксиса:
- Первый тип-параметр (`SpeechBarksComponent`) — «фильтр»: обработчик вызовется ТОЛЬКО для сущностей, у которых есть этот компонент.
- Второй тип-параметр (`EntitySpokeEvent`) — тип события.
- `OnEntitySpoke` — метод-обработчик.

#### OnEntitySpoke() — обработка речи

```csharp
private void OnEntitySpoke(EntityUid uid, SpeechBarksComponent component, EntitySpokeEvent args)
{
    if (!_isEnabled)
        return;

    var ev = new TransformSpeakerBarkEvent(uid, component.Data.Copy());
    RaiseLocalEvent(uid, ev);

    var message = args.ObfuscatedMessage ?? args.Message;
    var soundSpecifier = ev.Data.Sound ?? _proto.Index(ev.Data.Proto).Sound;

    foreach (var ent in _lookup.GetEntitiesInRange(Transform(uid).Coordinates, 10f))
    {
        if (!_mind.TryGetMind(ent, out _, out var mind) || mind.UserId == null ||
            !_player.TryGetSessionById(mind.UserId, out var session))
            continue;

        RaiseNetworkEvent(new PlaySpeechBarksEvent(
            GetNetEntity(uid), message, soundSpecifier,
            ev.Data.Pitch, ev.Data.MinVar, ev.Data.MaxVar,
            args.ObfuscatedMessage != null), session);
    }
}
```

Пошагово:

1. **Проверка включённости.** Если барки отключены через CVar — выходим.

2. **TransformSpeakerBarkEvent.** Создаём событие-трансформацию с КОПИЕЙ данных барка (`Copy()` — чтобы голосовая маска а не испортила оригинальные данные). Вызываем `RaiseLocalEvent` — система инвентаря прокинет это событие через все надетые предметы. Если на персонаже голосовая маска, она перезапишет `ev.Data` на свои настройки.

3. **Определение сообщения.** `args.ObfuscatedMessage ?? args.Message` — если сообщение зашифровано (шёпот), берём зашифрованную версию. Иначе — обычную.

4. **Определение звука.** `ev.Data.Sound ?? _proto.Index(ev.Data.Proto).Sound` — берём звук из данных (если он был кэширован) или достаём из прототипа по ID.

5. **Рассылка.** `GetEntitiesInRange(Transform(uid).Coordinates, 10f)` — находим все сущности в радиусе 10 тайлов от говорящего. Для каждой проверяем: есть ли у неё «разум» (реальный игрок) и если он не вышел из игры. Если да — отправляем сетевое событие `PlaySpeechBarksEvent` этому конкретному клиенту.

6. **Определение шёпота.** `args.ObfuscatedMessage != null` — если есть зашифрованное сообщение, значит это шёпот. Это влияет на громкость и дальность на клиенте.

---

### 2. Content.Server/_ECHO/Barks/Systems/VoiceMaskSystem.Barks.cs

Это **partial class** — расширение файла `VoiceMaskSystem.cs`. Partial class в C# позволяет разделить один класс на несколько файлов (удобно для модульности).

```csharp
public partial class VoiceMaskSystem
{
    private void InitializeBarks() { ... }
    private void OnSpeakerVoiceTransform(...) { ... }
    private void OnChangeBark(...) { ... }
    private void OnChangePitch(...) { ... }
}
```

#### InitializeBarks()

```csharp
private void InitializeBarks()
{
    SubscribeLocalEvent<VoiceMaskComponent, InventoryRelayedEvent<TransformSpeakerBarkEvent>>(OnSpeakerVoiceTransform);
    SubscribeLocalEvent<VoiceMaskComponent, VoiceMaskChangeBarkMessage>(OnChangeBark);
    SubscribeLocalEvent<VoiceMaskComponent, VoiceMaskChangeBarkPitchMessage>(OnChangePitch);
}
```

Подписывается на три события:
1. `InventoryRelayedEvent<TransformSpeakerBarkEvent>` — когда персонаж говорит, система инвентаря передаёт `TransformSpeakerBarkEvent` каждому надетому предмету. `InventoryRelayedEvent<...>` — обёртка, которая говорит: «это событие пришло через систему инвентаря, а внутри лежит оригинальное событие в поле `.Args`».
2. `VoiceMaskChangeBarkMessage` — игрок поменял барк через UI голосовой маски.
3. `VoiceMaskChangeBarkPitchMessage` — игрок поменял питч через UI голосовой маски.

#### OnSpeakerVoiceTransform() — подмена барка

```csharp
private void OnSpeakerVoiceTransform(EntityUid uid, VoiceMaskComponent component,
    ref InventoryRelayedEvent<TransformSpeakerBarkEvent> args)
{
    if (!_proto.TryIndex<BarkPrototype>(component.BarkId, out var proto))
        return;

    args.Args.Data.Pitch = Math.Clamp(component.BarkPitch,
        _cfgManager.GetCVar(UCCVars.BarksMinPitch),
        _cfgManager.GetCVar(UCCVars.BarksMaxPitch));
    args.Args.Data.Sound = proto.Sound;
}
```

Когда персонаж с голосовой маской говорит:
1. Проверяем, существует ли прототип барка маски. `TryIndex` — безопасная версия `Index` (не крашится если прототип не найден).
2. Подменяем питч (с зажиманием в допустимый диапазон через `Math.Clamp`).
3. Подменяем звук на звук из барка маски.

После этого `SpeechBarksSystem.OnEntitySpoke()` продолжит работу с подменёнными данными.

#### OnChangeBark() / OnChangePitch() — обработка сообщений от UI маски

Когда игрок через UI голосовой маски меняет барк или питч, клиент шлёт BUI-сообщение серверу:
```csharp
private void OnChangeBark(EntityUid uid, VoiceMaskComponent component, VoiceMaskChangeBarkMessage message)
{
    if (!_proto.HasIndex<BarkPrototype>(message.Proto))
    {
        _popupSystem.PopupEntity(Loc.GetString("voice-mask-voice-popup-invalid"), uid);
        return;
    }
    component.BarkId = message.Proto;
    _popupSystem.PopupEntity(Loc.GetString("voice-mask-voice-popup-success"), uid);
    UpdateUI((uid, component));
}
```
Сервер проверяет валидность (существует ли такой прототип), сохраняет в компонент маски и обновляет UI.

---

### 3. Content.Server/_ECHO/Barks/Systems/VoiceOverrideSystem.Barks.cs

```csharp
public sealed partial class VoiceOverrideSystem
{
    private void InitializeBarks()
    {
        SubscribeLocalEvent<VoiceOverrideComponent, TransformSpeakerBarkEvent>(OnTransformSpeakerBark);
    }

    private void OnTransformSpeakerBark(Entity<VoiceOverrideComponent> entity, ref TransformSpeakerBarkEvent args)
    {
        if (!entity.Comp.Enabled)
            return;
        args.Data = entity.Comp.Bark ?? args.Data;
    }
}
```

**Что это:** Перезапись барка для конкретной сущности. В отличие от голосовой маски (надеваемый предмет), `VoiceOverrideComponent` — компонент, который можно добавить любой сущности (например, NPC или боту).

**Оператор `??`:** `entity.Comp.Bark ?? args.Data` — если в компоненте задан барк, используем его. Если `null` — оставляем оригинальный.

---

## <span style="color:#66FF66">Новые файлы — Клиент</span>

### 1. Content.Client/_ECHO/Barks/Systems/SpeechBarksSystem.cs

Главный клиентский файл. Именно он **проигрывает звуки**.

```csharp
public sealed class SpeechBarksSystem : SharedSpeechBarksSystem
```

#### Initialize() — подписки

```csharp
public override void Initialize()
{
    base.Initialize();
    _cfg.OnValueChanged(UCCVars.BarksVolume, OnVolumeChanged, true);
    SubscribeNetworkEvent<PlaySpeechBarksEvent>(OnEntitySpoke);
}
```

- `OnValueChanged(UCCVars.BarksVolume, ...)` — следим за настройкой громкости (каждый клиент может настроить отдельно).
- `SubscribeNetworkEvent<PlaySpeechBarksEvent>(...)` — слушаем сетевое событие от сервера.

#### Shutdown() — отписка

```csharp
public override void Shutdown()
{
    base.Shutdown();
    _cfg.UnsubValueChanged(UCCVars.BarksVolume, OnVolumeChanged);
}
```
При выгрузке системы отписываемся от CVarа, чтобы не было утечек памяти.

#### AdjustVolume() — расчёт громкости

```csharp
private float AdjustVolume(bool isWhisper)
{
    return isWhisper ? _volume - 4f : _volume;
}
```
Шёпот тише на 4 единицы (в децибелах).

#### OnEntitySpoke() — проигрывание барка

```csharp
private async void OnEntitySpoke(PlaySpeechBarksEvent ev)
{
    if (ev.Message == null || ev.Source == null) return;

    var entity = GetEntity(ev.Source.Value);
    if (entity == EntityUid.Invalid || !Exists(entity) || !HasComp<TransformComponent>(entity))
        return;

    var audioParams = AudioParams.Default
        .WithVolume(AdjustVolume(ev.IsWhisper))
        .WithMaxDistance(ev.IsWhisper ? SharedChatSystem.WhisperMuffledRange : SharedChatSystem.VoiceRange);

    if (ev.Message.EndsWith('!'))
        audioParams = audioParams.WithVolume(audioParams.Volume * 1.2f);

    var count = ev.Message.Length / 3f;

    for (var i = 0; i < count; i++)
    {
        if (_player.LocalSession == null) break;

        _audio.PlayEntity(
            ev.SoundSpecifier,
            _player.LocalSession,
            entity,
            audioParams.WithPitchScale(_random.NextFloat(ev.Pitch - 0.1f, ev.Pitch + 0.1f))
        );

        await Task.Delay(TimeSpan.FromSeconds(_random.NextFloat(ev.LowVar, ev.HighVar)));
    }
}
```

Метод помечен как `async` — он использует `await` для пауз между звуками.

Пошагово:

1. **Валидация.** Проверяем что сообщение и источник не null, сущность существует, и у неё есть позиция в мире (`TransformComponent`).

2. **Настройка аудио.** `AudioParams.Default` — стандартные параметры. Добавляем:
   - Громкость (с учётом шёпота).
   - Максимальную дистанцию слышимости (для шёпота — `WhisperMuffledRange`, для обычной речи — `VoiceRange`).
   - Если сообщение заканчивается на `!` — увеличиваем громкость на 20%.

3. **Количество звуков.** `ev.Message.Length / 3f` — примерно один звук на каждые 3 символа. Например, сообщение из 15 символов = 5 звуков.

4. **Цикл проигрывания.**
   - `_audio.PlayEntity(...)` — проигрывает звук, привязанный к позиции сущности (позиционный звук: чем дальше, тем тише).
   - `WithPitchScale(_random.NextFloat(ev.Pitch - 0.1f, ev.Pitch + 0.1f))` — небольшое случайное отклонение питча (±0.1) для естественности.
   - `await Task.Delay(...)` — пауза между звуками. Длительность — случайное число между `LowVar` и `HighVar`.

#### PlayDataPreview() — предпрослушивание

```csharp
public async void PlayDataPreview(string protoId, float pitch, float lowVar, float highVar)
```

Аналогичен `OnEntitySpoke()`, но:
- Использует `_audio.PlayGlobal(...)` вместо `PlayEntity(...)` — звук не привязан к позиции, играет «в голове» игрока.
- Используется при предпрослушивании в UI создания персонажа.
- Берёт текст из `_sampleText` ("Съешь этих французских булок, да выпей чаю.").

---

### 2. Content.Client/_ECHO/Barks/BarkTab.xaml + BarkTab.xaml.cs

**BarkTab.xaml** — разметка UI окна выбора барка (визуальная часть).
**BarkTab.xaml.cs** — логика UI окна (code-behind).

#### Ключевые элементы XAML:

- `SearchEdit` — поле поиска по имени барка.
- `CategoriesContainer` — контейнер для кнопок категорий (заполняется динамически из кода).
- `BarksGrid` — контейнер для кнопок барков (заполняется динамически).
- `PitchEdit`, `DelayVariationMinEdit`, `DelayVariationMaxEdit` — поля ввода настроек.

#### Code-Behind (BarkTab.xaml.cs) — ключевые методы

**Конструктор:**
```csharp
public BarkTab()
{
    RobustXamlLoader.Load(this);          // Загружает XAML-разметку
    IoCManager.InjectDependencies(this);   // Внедряет [Dependency]

    _barkSystem = IoCManager.Resolve<IEntityManager>().System<SpeechBarksSystem>();

    SearchEdit.OnTextChanged += OnSearchTextChanged;
    PitchEdit.OnTextChanged += OnPitchTextChanged;
    DelayVariationMinEdit.OnTextChanged += OnMinVarTextChanged;
    DelayVariationMaxEdit.OnTextChanged += OnMaxVarTextChanged;

    LoadBarks();
}
```

Загружает все прототипы барков, группирует по категориям, подписывается на изменения полей ввода.

**LoadBarks():**
```csharp
_allBarks = _prototypeManager
    .EnumeratePrototypes<BarkPrototype>()    // Получить все прототипы типа BarkPrototype
    .Where(b => b.RoundStart)                // Только те, что доступны при создании персонажа
    .OrderBy(b => Loc.GetString(b.Name))     // Сортировка по локализованному имени
    .ToList();

_barksByCategory = _allBarks
    .GroupBy(b => b.Category)                // Группировка по категории
    .ToDictionary(g => g.Key, g => g.ToList());
```

**FilterBarks():** Фильтрация по выбранной категории и строке поиска. Вызывается при любом изменении фильтров.

**OnBarkButtonPressed():** При клике на барк:
1. Запоминает выбранный ID.
2. Вызывает `OnBarkSelected?.Invoke(barkId)` — оповещает подписчиков (HumanoidProfileEditor).
3. Обновляет подсветку кнопок.
4. Проигрывает превью.

**События (delegates):**
```csharp
public event Action<string>? OnBarkSelected;
public event Action<float>? OnPitchChanged;
public event Action<float>? OnMinVarChanged;
public event Action<float>? OnMaxVarChanged;
```
Это механизм обратной связи: BarkTab не знает ничего о профиле или сохранении. Он просто говорит «пользователь выбрал другой барк» через событие, а кто подписался — тот и обработает.

---

### 3. Content.Client/_ECHO/Barks/UI/HumanoidProfileEditor.Barks.cs

**Partial class** — расширение `HumanoidProfileEditor` (редактор персонажа в лобби). Связывает BarkTab с системой профиля.

#### InitializeBarks()

```csharp
private void InitializeBarks()
{
    _barkList = _prototypeManager.EnumeratePrototypes<BarkPrototype>()
        .Where(o => o.RoundStart)
        .OrderBy(o => Loc.GetString(o.Name))
        .ToList();

    BarkProtoButton.OnPressed += _ => OpenBarkWindow();
    BarkPlayButton.OnPressed += _ => PlayPreviewBark();
}
```

Загружает список барков и привязывает кнопки:
- `BarkProtoButton` — кнопка «Стандарт 1» (открывает окно выбора барка).
- `BarkPlayButton` — кнопка воспроизведения превью.

#### OpenBarkWindow() — открытие окна выбора

```csharp
private void OpenBarkWindow()
{
    if (Profile is null) return;

    // Закрываем старое окно если есть
    if (_barkWindow != null) { _barkWindow.Close(); _barkWindow = null; }

    // Создаём BarkTab с текущими настройками из профиля
    var barkTab = new BarkTab();
    barkTab.SetSelectedBark(Profile.Bark.Proto, Profile.Bark.Pitch, Profile.Bark.MinVar, Profile.Bark.MaxVar);

    // Подписываемся на события изменений
    barkTab.OnBarkSelected += OnBarkSelected;
    barkTab.OnPitchChanged += OnBarkPitchChanged;
    barkTab.OnMinVarChanged += OnBarkMinVarChanged;
    barkTab.OnMaxVarChanged += OnBarkMaxVarChanged;

    // Создаём окно и показываем
    _barkWindow = new FancyWindow { Title = ..., MinSize = new Vector2(750, 600) };
    _barkWindow.ContentsContainer.AddChild(barkTab);
    _barkWindow.OpenCentered();
}
```

#### Обработчики изменений

```csharp
private void OnBarkSelected(string barkId)
{
    SetBarkProto(barkId);       // Применяет изменение к профилю
    UpdateBarkButtonText();     // Обновляет текст на кнопке
    UpdateSaveButton();         // Обновляет состояние кнопки «Сохранить»
}
```

Каждый обработчик вызывает соответствующий `SetBark*()` метод (определён в основном файле `HumanoidProfileEditor.xaml.cs`), а затем `UpdateSaveButton()` для активации кнопки сохранения.

#### UpdateBarkVoicesControls()

Вызывается при загрузке/сбросе профиля. Обновляет текст на кнопке и состояние BarkTab (если окно открыто).

---

## <span style="color:#FF9966">Изменения в существующих файлах</span>

### 1. Content.Shared/Preferences/HumanoidCharacterProfile.cs

Главный файл хранения данных профиля персонажа.

#### Добавлено: поле Bark
```csharp
// ECHO-Tweak : Barks
[DataField]
public BarkData Bark = new();
// ECHO-Tweak : Barks
```
Хранит настройки барка в профиле. Значение по умолчанию — `new BarkData()` (Human1, питч 1.0, задержка 0.1–0.5).

#### Изменён: конструктор

Добавлен параметр `BarkData bark` в конструктор + присвоение `Bark = bark`. Copy-конструктор копирует `other.Bark`.

#### Добавлены: With-методы

```csharp
public HumanoidCharacterProfile WithBarkProto(string bark) => new(this) { Bark = Bark.WithProto(bark) };
public HumanoidCharacterProfile WithBarkPitch(float pitch) => new(this) { Bark = Bark.WithPitch(pitch) };
public HumanoidCharacterProfile WithBarkMinVariation(float variation) => new(this) { Bark = Bark.WithMinVar(variation) };
public HumanoidCharacterProfile WithBarkMaxVariation(float variation) => new(this) { Bark = Bark.WithMaxVar(variation) };
```

Каждый создаёт НОВЫЙ профиль с изменённым параметром барка. Паттерн иммутабельности: `new(this)` вызывает copy-конструктор, а `{ Bark = ... }` перезаписывает одно поле.

#### Изменён: MemberwiseEquals

```
Было:
    if (FlavorText != other.FlavorText) return false;
    return Appearance.Equals(other.Appearance);

Стало:
    if (FlavorText != other.FlavorText) return false;
    if (!Bark.MemberwiseEquals(other.Bark)) return false; // ECHO-Tweak : Barks
    return Appearance.Equals(other.Appearance);
```

**Зачем:** Без этой строки система не видела изменения в барках как «изменения профиля». Это приводило к тому, что кнопка «Сохранить» оставалась неактивной, и настройки барков не сохранялись.

---

### 2. Content.Client/Lobby/UI/HumanoidProfileEditor.xaml

Добавлен блок UI:
```xml
<!-- ECHO-Tweak : Barks -->
<BoxContainer HorizontalExpand="True" Visible="False" Name="BarksContainer">
    <Label Text="{Loc 'humanoid-profile-editor-bark-label'}" />
    <Control HorizontalExpand="True"/>
    <Button Name="BarkProtoButton" HorizontalAlignment="Right" MinWidth="150" />
    <Button Name="BarkPlayButton" Text="{Loc 'humanoid-profile-editor-voice-play'}" MaxWidth="80" />
</BoxContainer>
<!-- ECHO-Tweak : Barks -->
```

Контейнер скрыт по умолчанию (`Visible="False"`) и показывается только если барки включены через CVar.

---

### 3. Content.Client/Lobby/UI/HumanoidProfileEditor.xaml.cs

#### Инициализация (в конструкторе, ~строка 250)
```csharp
if (configurationManager.GetCVar(UCCVars.BarksEnabled))
{
    BarksContainer.Visible = true;
    InitializeBarks();
}
```
Показывает контейнер барков и вызывает `InitializeBarks()` из partial class.

#### Обновление при загрузке профиля (~строка 670)
```csharp
UpdateBarkVoicesControls(); // ECHO-Tweak : Barks
```
При установке/сбросе профиля через `SetProfile()` обновляет UI барков.

#### Set-методы (~строки 1080-1110)

```csharp
private void SetBarkProto(string prototype)
{
    Profile = Profile?.WithBarkProto(prototype);
    ReloadPreview();
    SetDirty();
}

private void SetBarkPitch(float pitch)
{
    Profile = Profile?.WithBarkPitch(Math.Clamp(pitch,
        _cfgManager.GetCVar(UCCVars.BarksMinPitch),
        _cfgManager.GetCVar(UCCVars.BarksMaxPitch)));
    ReloadPreview();
    SetDirty();
}
```

Каждый метод:
1. Создаёт новый профиль с изменённым параметром (иммутабельность).
2. `ReloadPreview()` — обновляет 3D-модель персонажа в предпросмотре.
3. `SetDirty()` — помечает профиль как «изменённый» (чтобы активировать кнопку «Сохранить»).

**Clamp-валидация:** Питч зажимается между `BarksMinPitch` и `BarksMaxPitch`. Задержки валидируются так: MinVar не может быть больше MaxVar и наоборот.

---

### 4. Content.Server.Database/Model.cs

```csharp
// ECHO-Tweak : Barks
public string BarkProto { get; set; } = null!;
public float BarkPitch { get; set; } = 1f;
public float LowBarkVar { get; set; } = 0.1f;
public float HighBarkVar { get; set; } = 0.5f;
// ECHO-Tweak : Barks
```

Добавлены колонки в модель базы данных (Entity Framework). Каждое поле = колонка в таблице `profile`.

---

### 5. Content.Server/Database/ServerDbBase.cs

#### Чтение из БД:
```csharp
new BarkData(profile.BarkProto, profile.BarkPitch, profile.LowBarkVar, profile.HighBarkVar)
```
При загрузке профиля из базы данных создаётся объект `BarkData` с сохранёнными значениями.

#### Запись в БД:
```csharp
profile.BarkProto = humanoid.Bark.Proto;
profile.BarkPitch = humanoid.Bark.Pitch;
profile.LowBarkVar = humanoid.Bark.MinVar;
profile.HighBarkVar = humanoid.Bark.MaxVar;
```
При сохранении профиля данные копируются из `BarkData` в модель БД.

---

### 6. Content.Shared/Humanoid/HumanoidProfileSystem.cs

```csharp
[Dependency] private readonly SharedSpeechBarksSystem _barks = default!;
```

В методе `ApplyProfileTo()`:
```csharp
_barks.SetBarkData(ent, profile.Bark);
```

**Зачем:** Когда игрок спавнится (или профиль применяется к сущности), нужно записать настройки барка из профиля в `SpeechBarksComponent` сущности. Без этой строки персонаж будет использовать барк по умолчанию, а не тот, который игрок выбрал.

---

### 7. Content.Server/VoiceMask/VoiceMaskSystem.cs

Строка ~57:
```csharp
InitializeBarks(); // ECHO-Tweak : Barks
```
Вызывается в `Initialize()` основного класса, инициализирует подписки из `VoiceMaskSystem.Barks.cs`.

Строка ~195 (UpdateUI):
```csharp
new VoiceMaskBuiState(..., entity.Comp.BarkId, entity.Comp.BarkPitch)
```
При обновлении UI голосовой маски передаются текущие настройки барка.

---

### 8. Content.Server/VoiceMask/VoiceMaskComponent.cs

```csharp
[DataField, ViewVariables(VVAccess.ReadWrite)]
public string BarkId = "Human1";

[DataField, ViewVariables(VVAccess.ReadWrite)]
public float BarkPitch = 1f;
```

Голосовая маска хранит свои настройки барка отдельно от персонажа.

---

### 9. Content.Server/Speech/EntitySystems/VoiceOverrideSystem.cs

```csharp
InitializeBarks(); // ECHO-Tweak : Barks
```

Аналогично VoiceMaskSystem — вызов инициализации из partial class.

---

### 10. Content.Server/Speech/Components/VoiceOverrideComponent.cs

```csharp
[DataField]
public BarkData? Bark;
```

Позволяет задать барк для VoiceOverride через YAML прототипы.

---

### 11. Content.Shared/VoiceMask/SharedVoiceMaskSystem.cs

Добавлены поля `Bark` и `Pitch` в `VoiceMaskBuiState`, чтобы UI маски голоса мог отображать текущие настройки барка.

---

## YAML-прототипы и ресурсы

### Resources/Prototypes/_ECHO/Barks/roundstart.yml

76 прототипов барков, доступных при создании персонажа.

Формат:
```yaml
- type: speechBark
  id: Human1              # Уникальный ID
  name: bark-Human1       # Ключ локализации для названия
  category: Standard_barks # Категория (для группировки в UI)
  sound:
    path: /Audio/_ECHO/Barks/speak_1.ogg  # Путь к звуковому файлу
```

Некоторые барки используют SoundCollection — коллекцию звуков, из которой при каждом проигрывании случайно выбирается один:
```yaml
- type: speechBark
  id: SkeletonBarkOne
  name: bark-SkeletonBarkOne
  sound:
    collection: SkeletonBarkCollection  # Ссылка на коллекцию
```

**Категории:**
| Ключ категории            | Описание                     |
|---------------------------|------------------------------|
| Standard_barks            | Стандартные барки            |
| Undertale_barks           | Барки из Undertale           |
| Undertale_yellow_barks    | Барки из Undertale Yellow    |
| Deltarune_barks           | Барки из Deltarune           |
| Deltarune_rewritten_barks | Барки из Deltarune Rewritten |
| Underswap_barks           | Барки из Underswap           |
| Minecraft_barks           | Барки из Minecraft           |

### Resources/Prototypes/_ECHO/Barks/misc.yml

12 служебных барков (`roundStart: false`) — для призраков, скелетов, роботов, животных и т.д. Не отображаются в UI создания персонажа, используются в YAML прототипах сущностей.

### Resources/Prototypes/_ECHO/SoundCollections/barks.yml

Коллекции звуков для барков, которые используют несколько звуковых файлов.

---

## Локализация

### Resources/Locale/ru-RU/_ECHO/preferences/ui/humanoid-profile-editor.ftl

Строки для UI:
```
humanoid-profile-editor-bark-label = Барк
humanoid-profile-editor-bark-window-title = Выбор барка
humanoid-profile-editor-bark-placeholder = Поиск...
humanoid-profile-editor-bark-categories = Категории
humanoid-profile-editor-bark-settings = Настройки
humanoid-profile-editor-bark-pitch-label = Питч:
humanoid-profile-editor-bark-delay-label = Задержка:
humanoid-profile-editor-bark-none = Не выбран
```

### Resources/Locale/ru-RU/_ECHO/prototypes/barks/roundstart.ftl

Локализация имён всех 76 барков. Формат:
```
bark-Human1 = Стандарт 1
bark-Papyrus = Папирус
bark-Sans = Санс
```

---

## CVars — настройки администратора

Настройка сервера:
```
cvar barks.enabled true/false     -- включить/выключить барки
cvar barks.min_pitch 0.6          -- минимальный питч
cvar barks.max_pitch 1.5          -- максимальный питч
cvar barks.min_delay 0.1          -- минимальная задержка
cvar barks.max_delay 0.6          -- максимальная задержка
```

Клиентская настройка:
```
cvar barks.volume 1.0             -- громкость барков
```

---

## Путь данных: от нажатия Enter до звука

Подробная пошаговая цепочка для полного понимания:

### Этап 1: Создание персонажа (сохранение настроек)

```
1. Игрок открывает меню создания персонажа
2. Нажимает кнопку барка → OpenBarkWindow()
3. Выбирает барк / меняет питч / задержку
4. BarkTab вызывает OnBarkSelected / OnPitchChanged / etc.
5. HumanoidProfileEditor.Barks.cs → SetBarkProto() / SetBarkPitch() / etc.
6. Создаётся новый Profile с изменённым Bark (иммутабельность)
7. SetDirty() → IsDirty = true → кнопка «Сохранить» становится активной
8. Игрок нажимает «Сохранить» → Save?.Invoke()
9. LobbyUIController.SaveProfile() → отправка профиля на сервер
10. Сервер записывает Bark в БД через ServerDbBase
```

### Этап 2: Спавн персонажа

```
1. Раунд начинается, персонаж спавнится
2. HumanoidProfileSystem.ApplyProfileTo() вызывается
3. _barks.SetBarkData(ent, profile.Bark) — записывает BarkData в SpeechBarksComponent
4. Кэширует звук: comp.Data.Sound = _proto.Index(comp.Data.Proto).Sound
5. Персонаж готов «говорить»
```

### Этап 3: Игрок пишет в чат

```
1. Игрок набирает сообщение, нажимает Enter
2. ChatSystem (ванильная) обрабатывает сообщение
3. Вызывается EntitySpokeEvent
4. SpeechBarksSystem.OnEntitySpoke() (сервер) ловит событие
5. Создаёт TransformSpeakerBarkEvent с копией BarkData
6. RaiseLocalEvent — маска голоса / VoiceOverride могут подменить данные
7. Находит всех игроков в радиусе 10 тайлов
8. Отправляет PlaySpeechBarksEvent каждому клиенту
9. Клиент получает событие
10. SpeechBarksSystem.OnEntitySpoke() (клиент) проигрывает серию звуков
```

---

## Частые вопросы для новых кодеров

### Как добавить новый барк?

1. Положите звуковой файл (.ogg) в `Resources/Audio/_ECHO/Barks/`.
2. Добавьте прототип в `Resources/Prototypes/_ECHO/Barks/roundstart.yml`:
```yaml
- type: speechBark
  id: MyNewBark
  name: bark-MyNewBark
  category: Standard_barks
  sound:
    path: /Audio/_ECHO/Barks/my_new_bark.ogg
```
3. Добавьте локализацию в `Resources/Locale/ru-RU/_ECHO/prototypes/barks/roundstart.ftl`:
```
bark-MyNewBark = Мой новый барк
```

### Как добавить барк с несколькими звуками?

1. Создайте коллекцию в `Resources/Prototypes/_ECHO/SoundCollections/barks.yml`:
```yaml
- type: soundCollection
  id: MyBarkCollection
  files:
    - /Audio/_ECHO/Barks/my_bark_1.ogg
    - /Audio/_ECHO/Barks/my_bark_2.ogg
    - /Audio/_ECHO/Barks/my_bark_3.ogg
```
2. В прототипе барка укажите коллекцию:
```yaml
- type: speechBark
  id: MyMultiBark
  name: bark-MyMultiBark
  sound:
    collection: MyBarkCollection
```

### Как добавить новую категорию?

1. Используйте любую строку в поле `category` прототипа:
```yaml
  category: My_custom_barks
```
2. Добавьте локализацию категории:
```
bark-category-My_custom_barks = Мои барки
```

### Как добавить барк для NPC (не для игрока)?

Добавьте прототип с `roundStart: false` в `misc.yml`:
```yaml
- type: speechBark
  id: RobotBark
  name: bark-RobotBark
  roundStart: false
  sound:
    path: /Audio/_ECHO/Barks/robot.ogg
```
Затем в прототипе сущности NPC добавьте компонент:
```yaml
- type: entity
  id: MyRobotNPC
  components:
  - type: SpeechBarks
    data:
      proto: RobotBark
```
